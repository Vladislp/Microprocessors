ADC - Analog Digital Converter

*Как правило, АЦП — электронное устройство, преобразующее напряжение в двоичный цифровой код. Можно измерять температуру.
*Для того, что бы начать измерять нужно написать логический один в ADSC. Он будет один до того, как не закончится какое то измерение. Само железо выключить.
*Если поменять канал на какой то другой то в начале АДС закончит свою работу, а потом только переключится на другой канал.
*Если во время измерение одного сигнала, пришел какой то новый, то его игнорируют.
*Прерывание должно быть выключено, перед началом нового конвертирования.
*Если разные варианты, что бы включить измерение:
	~Auto Triggering
	~Free Running mode
	~Trigger Event
*У ADC есть так называемый prescaler, который задает для ADC подходящий sagedus.
	~ADC prescaler можно задать благодаря ADPS bits, в ADCSRA
	~Prescaler начинает работать с момента включения, вставив нужный бит ADEN --> ADCSRA.
	~Prescaler работает столько, сколько есть логический один... А если логический ноль, то он постоянно ресетится.
*Регистр ADMUX задаёт входной контакт порта A для подключения ADC, ориентирование результата и выбор опорной частоты.
*Прерывание происходит постоянно, когда конвертация закончилась.



.EQU OSCILLATION_FREQ = 2000000
.EQU BAUD = 9600
.EQU UBRR_VALUE = (OSCILLATION_FREQ/16/BAUD -1)

LDI R16, 0xFF ( LOW )
OUT SPL, R16
LDI R16, 0x10 ( HIGH )
OUT SPH, R16

LDI R16, LOW(UBRR_VALUE) // Посчитать "Baud Rate" для асинхронного режима.
LDI R17, HIGH(UBRR_VALUE) // Baud Rate это скорость передачи данных bit/s.
// UBRR - определяет скорость приема/передачи данных

Main:
	CALL ADC_init
	CALL USART_init
	
	loop:
		LDS R16, ADCL // Результат измерения ADC
		LDS R17, ADCH // Результат измерения ADC
		
	        LDI R20, '9'
		LDI R18, LOW(1023) // Мы должны постоянно проверять значения, которые получаем
		LDI R19, HIGH(1023) // Если больше, то просто меняем регистер R24, на R20...который хранит в себе значения
		CALL Check_if // Вызываем процедуру, которая будет менять/ждать значения и разрешения.
		LDI R20, '8'
		LDI R18, LOW(900)
		LDI R19, HIGH(900)
		CALL Check_if
		LDI R20, '7'
		LDI R18, LOW(800)
		LDI R19, HIGH(800)
		CALL Check_if
		LDI R20, '6'
		LDI R18, LOW(700)
		LDI R19, HIGH(700)
		CALL Check_if
		LDI R20, '5'
		LDI R18, LOW(600)
		LDI R19, HIGH(600)
		CALL Check_if
		LDI R20, '4'
		LDI R18, LOW(500)
		LDI R19, HIGH(500)
		CALL Check_if
		LDI R20, '3'
		LDI R18, LOW(400)
		LDI R19, HIGH(400)
		CALL Check_if
		LDI R20, '2'
		LDI R18, LOW(300)
		LDI R19, HIGH(300)
		CALL Check_if
		LDI R20, '1'
		LDI R18, LOW(200)
		LDI R19, HIGH(200)
		CALL Check_if
		LDI R20, '0'
		LDI R18, LOW(100)
		LDI R19, HIGH(100)
		CALL Check_if
		

		CALL Send_character
		RJMP loop

Check_if:
	CP R16, R18 // Сравниваем показания с ADC вместе с тем, которые мы хотим дать String-ам 
	CPC R17, R19
	BRGE pass // Проверяем, больше ли значение...так как по заданию он должен быть в промежутке
		MOV R24, R20 // Вставляем то, то хотим передать в регистер R24, который ждет... пока сможет передовать.
	pass:
RET

Send_character:
	PUSH R24

	CALL Wait_for_TX
	STS UDR1, R24

	POP R24
RET

ADC_init:
	PUSH R16
	PUSH R17

	LDI R16, 0b01000010 // REFS0 , MUX 1
	STS ADMUX, R16
	LDI R16, 0b11100000 // ADEN, ADSC, ADATE
	STS ADCSRA, R16
	
	POP R17
	POP R16
RET

Wait_for_TX:
	PUSH R16 // TX - отправить

	delay_ms_loop:
		LDS R16, UCSR1A // Пишем на регистер, что есть в К16
		ANDI R16, 0b00100000 // ANDI с констант и помещает назад в регистер
	BREQ delay_ms_loop

	POP R16
RET

USART_init:
	PUSH R16
	PUSH R17

	STS UBRR1L, R16
	STS UBRR1H, R17
	LDI R16, (1 << TXEN1)
	STS UCSR1B, R16
	LDI R16, (1 << UCSZ10)|((1 << UCSZ11))
	STS UCSR1C, R16
	
	POP R17
	POP R16
RET
